 , __                               _  
/|/  \                             | | 
 |___/ ,_    __ _|_  __   __   __  | | 
 |    /  |  /  \_|  /  \_/    /  \_|/  
 |       |_/\__/ |_/\__/ \___/\__/ |__/
                                       
                                       
--  This document was created by Xuanming in 2023, thanks for your reading



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2PC
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
2PC 官方翻译为二阶段提交协议 (2 Phase Commit)
2PC 把分布式集群的事务提交过程切分为请求事务/ 提交事务 (回滚事务) 在内的两个顺序阶段, 2PC 常被关系型数据库用于处理分布式事务
2PC 把分布式集群的服务实例区分为协调者 (Coordinator)/ 参与者 (Participant): 协调者统一调度参与者的执行逻辑, 并决定参与者是否提交事务
2PC 的详细内容说明如下:

    阶段一: 请求事务
    ─────────────────────────────────────────────────────────────────
    1. 协调者向每个参与者发送事务内容, 询问参与者是否有条件能够提交事务
    2. 参与者执行事务并产生出重做数据 (redo data)/ 回退数据 (undo data) 写入事务日志文件
    3. 参与者向协调者反馈事务执行结果 (分为事务执行成功的响应与事务执行失败的响应)

    阶段二: 完成事务 [每个参与者的事务执行成功]
    ─────────────────────────────────────────────────────────────────
    1. 协调者向每个参与者发送事务提交请求
    2. 参与者提交事务
    3. 参与者反馈事务提交结果
    4. 协调者接收到每个参与者反馈的 ACK 消息之后, 完成整个分布式集群的一次事务提交

    阶段二: 回滚事务 [任意参与者的事务执行失败]
    ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
    1. 协调者向每个参与者发送事务回滚请求
    2. 参与者使用回退数据回滚事务
    3. 参与者反馈事务回滚结果
    4. 协调者接收到每个参与者反馈的 ACK 消息之后, 完成整个分布式集群的一次事务回滚



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3PC
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
3PC 官方翻译为三阶段提交协议 (3 Phase Commit)
3PC 把分布式集群的事务提交过程切分为提交请求事务/ 预提交事务 (中断事务)/ 提交事务 (回滚事务) 在内的三个顺序阶段
3PC 把分布式集群的服务实例区分为协调者 (Coordinator)/ 参与者 (Participant): 协调者统一调度参与者的执行逻辑, 并决定参与者是否提交事务
3PC 的详细内容说明如下:

    阶段一: 请求事务
    ─────────────────────────────────────────────────────────────────
    1. 协调者向每个参与者发送事务内容, 询问参与者是否有条件能够提交事务
    2. 参与者评估自身是否有条件能够提交事务
    3. 参与者向协调者反馈自身的条件评估结果

    阶段二: 预提交事务 [每个参与者的评估结果为成功]
    ─────────────────────────────────────────────────────────────────
    1. 协调者向每个参与者发送预提交请求, 协调者自身则进入准备状态
    2. 参与者执行事务并产生出重做数据 (redo data)/ 回退数据 (undo data) 写入事务日志文件
    3. 参与者向协调者反馈事务执行结果 (分为事务执行成功的响应与事务执行失败的响应)

    阶段二: 中断事务 [任意参与者的评估结果为失败]
    ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
    1. 协调者向每个参与者发送事务中断请求
    2. 参与者中断事务 (参与者在等待协调者消息超时之后, 会自行中断事务)

    阶段三: 提交事务 [每个参与者的事务执行成功]
    ─────────────────────────────────────────────────────────────────
    1. 协调者向每个参与者发送事务提交请求, 协调者自身则进入提交状态
    2. 参与者提交事务
    3. 参与者反馈事务提交结果
    4. 协调者接收到每个参与者反馈的 ACK 消息之后, 完成整个分布式集群的一次事务提交

    阶段三: 回滚事务 [任意参与者的事务执行失败]
    ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─ ─
    1. 协调者向每个参与者发送事务回滚请求
    2. 参与者使用回退数据回滚事务
    3. 参与者反馈事务回滚结果
    4. 协调者接收到每个参与者反馈的 ACK 消息之后, 完成整个分布式集群的一次事务回滚



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Paxos
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
Paxos 由旧金山的计算机科学家兰伯特 (Leslie Lamport) 设计, 协议名称取自希腊岛屿帕克索斯
Paxos 在分布式集群内, 允许 2n + 1 个服务实例中的 n 个服务实例宕机
Paxos 把分布式集群的服务实例分为下述不同角色:

    •  提议者 ( Proposer ) 发起提案 (提案编号, 提案内容)
    •  决策者 ( Acceptor ) 决定是否接受提案, 若提案被分布式集群中过半的决策者接受, 则提案被整个分布式集群批准生效
    •  学习者 ( Learner  ) 学习已被分布式集群批准生效的提案
    •  分布式集群的服务实例可以同时充当上述三种角色中的若干种, 同时分布式集群的服务实例保证消息内容不会被篡改

┌──────────────────────────────────────────────────────────┬──────────────────────────────────────────────────────────┐
│                         Proposer                         │                         Acceptor                         │
├──────────────────────────────────────────────────────────┼──────────────────────────────────────────────────────────┤
│                                                          │                                                          │
│   1. Choose a bigger number N for new proposal           │                                                          │
│   2. Broadcast Prepare(N) to                             │                                                          │
│       more than half of acceptors ╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌> 3. Response to Prepare(N):                            │
│                                                          │       •  if N > MinProposal then                         │
│                                                          │       •      MinProposal = N;                            │
│   4. Received response from majority: <╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌ •      return (AcceptProposal, AcceptValue);       │
│       •  if AcceptValue != NULL then                     │                                                          │
│       •      if Max(AcceptProposal) then                 │                                                          │
│       •          Value = AcceptValue;                    │                                                          │
│       •  else                                            │                                                          │
│       •      Value = Random();                           │                                                          │
│   5. Broadcast Accept(N, Value) to all acceptors ╌╌╌╌╌╌╌╌╌╌╌> 6. Response to Accept(N, Value):                      │
│                                                          │       •  if N >= MinProposal then                        │
│                                                          │       •      AcceptProposal = MinProposal = N;           │
│                                                          │       •      AcceptValue = Value;                        │
│   7. Judge response: <╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌ •      return MinProposal;                         │
│       •  if Count(response) > majority then              │                                                          │
│       •      Value is agreement;                         │                                                          │
│       •  else                                            │                                                          │
│       •      Goto(1);                                    │                                                          │
│                                                          │                                                          │
└──────────────────────────────────────────────────────────┴──────────────────────────────────────────────────────────┘

阅读上述伪代码时, 还请注意:

    1. 提议者使用时间戳拼接自增数字的方式, 确定全局有序值 N 作为提案编号
    2. 提议者向超过半数的决策者广播 Prepare(N) 请求
    3. 决策者在接收到 Prepare(N) 的时候:
        •  如果 N > MinProposal 为真, 则决策者设置自身记录的最小提案编号 MinProposal = N
        •  如果 N > MinProposal 为真, 则决策者返回自身已经批准的提案决议给提议者 (如果决策者尚未接受任何提案, 则返回一个空值 NULL)
        •  如果 N > MinProposal 为假, 则决策者无响应
    4. 提议者在接收到超过半数的决策者的请求响应之后:
        •  如果 AcceptValue != NULL 为真, 则提议者设置提案内容 Value = Max(AcceptProposal).AcceptValue
        •  如果 AcceptValue != NULL 为假, 则提议者使用随机数据设置提案内容
    5. 提议者向全部决策者广播 Accept(N, Value) 请求
    6. 决策者在接收到 Accept(N, Value) 的时候:
        •  如果 N >= MinProposal 为真, 则决策者接受提案 (AcceptProposal = MinProposal = N, AcceptValue = Value)
        •  如果 N >= MinProposal 为真, 则决策者接受提案的同时返回已经批准的最小提案编号给提议者
        •  如果 N >= MinProposal 为假, 则决策者无响应
    7. 提议者针对提案统计决策者的响应数量:
        •  如果超过半数的决策者都在接受并响应提案, 则提议者认为分布式集群就提案达成一致
        •  如果仅有不足半数的决策者接受并响应提案, 则提议者觉察分布式集群中的有其他提议者发起更新的提案, 提议者跳转至逻辑步骤 1

提案死循环和选举机制
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
    00:00:00.000  P0 提议者广播准备请求 Prepare(0), 决策者设置 MinProposal = 0
    00:00:00.001  P1 提议者广播准备请求 Prepare(1), 决策者设置 MinProposal = 1
    00:00:00.002  P0 提议者广播提案请求 Accept(0, V0), 决策者接收到提案请求时, 表达式 0 >= MinProposal 为假, 决策者忽略该提案
    00:00:00.003  P0 提议者跳转至逻辑步骤 1, 重新广播准备请求 Prepare(3), 决策者设置 MinProposal = 3
    00:00:00.004  P1 提议者广播提案请求 Accept(1, V1), 决策者接收到提案请求时, 表达式 1 >= MinProposal 为假, 决策者忽略该提案
    00:00:00.005  P1 提议者跳转至逻辑步骤 1, 重新广播准备请求 Prepare(5), 决策者设置 MinProposal = 5
    00:00:00.006  P0 提议者广播提案请求 Accept(3, V3), 决策者接收到提案请求时, 表达式 3 >= MinProposal 为假, 决策者忽略该提案
    ... ...       ... ...

    为保证提案的可持续性: 分布式集群的提议者内部选举主实例, 仅允许主实例广播提案, 主节点出现宕机, 则其余提议者再次选举主实例



━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ZAB
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
ZAB 官方翻译为原子消息广播协议 (ZooKeeper Atomic Broadcast)
ZAB 是专用于 ZooKeeper 软件的分布式一致性协议, 具有领导选举/ 消息广播/ 崩溃恢复在内的三种基本工作模式
ZAB 把分布式集群中的服务实例分为下述不同角色:

    •  领导者 (Leader)   作为 ZooKeeper 集群中唯一的读写实例, 通过领导选举产生
    •  追随者 (Follower) 作为 ZooKeeper 集群中若干个只读实例, 能够参与选举领导者和事务的批准投票
    •  观察者 (Observer) 作为 ZooKeeper 集群中若干个只读实例, 无权参与选举领导者和事务的批准投票

领导选举
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
领导选举伴随由 EPOCH 值产生的领导任期
领导选举需要遵循下述基本规则:

    •  追随者始终把第一次的选票投给自己
    •  追随者向其他全部节点广播自己的投票结果, 并接收其他追随者发送的投票结果
    •  追随者选择事务编号最大的节点作为新一轮的投票对象, 若存在多个节点的事务编号相等, 选择节点编号最大的节点作为新一轮的投票对象
    •  追随者向其他全部节点广播自己新一轮的投票结果, 并接收其他追随者发送的新一轮的投票结果
    •  追随者们把过半投票投给同一个节点时, 即刻选出领导者

    ┌───────────────────────────┐
    │           VOTE            ├────────────────(SID, ZXID)
    ├───────────────────────────┤
    │ SID                       │  •  选票包含被推荐节点的节点编号
    │ ZXID                      │  •  选票包含被推荐节点的事务编号
    │ PEEREPOCH                 │  •  选票包含被推荐节点的领导任期
    │ ELECTIONEPOCH             │  •  选票包含逻辑时钟, 保障投票属于固定轮次的投票周期
    │ STATE                     │  •  选票包含投票节点的状态
    └───────────────────────────┘

    ┌───┐       (0,0)                   (1,0)                                               ┌────────────────────┐
    │ 0 ├╌╌╌╌╌╌╌╌╌o╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌┬╌╌╌╌o╌╌╌╌╌╌┬╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌> │      Follower      │
    └───┘                          ↑ ┊         ↑ ┊                                          └────────────────────┘
                ┌───┐       (1,0)  ┊ ↓  (1,0)  ┊ ↓                                          ┌────────────────────┐
                │ 1 ├╌╌╌╌╌╌╌╌╌o╌╌╌╌┴╌╌╌╌╌╌o╌╌╌╌┴╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌> │       Leader       │
                └───┘                                                                       └────────────────────┘
                            ┌───┐       (2,0)                                               ┌────────────────────┐
                            │ 2 ├╌╌╌╌╌╌╌╌╌o╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌> │      Follower      │
                            └───┘                                                           └────────────────────┘

上述图例的发生过程说明如下:

    1. 节点 0 启动, 并在启动选举中投票自己为领导者, 但不满足集群内投票过半原则, 节点 0 无法当选领导者
    2. 节点 1 启动, 并在启动选举中投票自己为领导者, 并把投票结果向节点 0 广播
    3. 节点 0 接收到节点 1 的投票结果, 比较选票 (0,0)/ (1,0), 节点 0 选择新一轮选举投票给节点 1
    3. 节点 1 接收到节点 0 的投票结果, 比较选票 (1,0)/ (0,0), 节点 1 选择新一轮选举投票给自己
    4. 第二轮投票开始, 节点 0 和节点 1 同时投票给节点 1 并交换投票信息, 节点 1 当选为领导者
    5. 节点 2 启动, 并在启动选举中投票自己为领导者, 但集群内已经存在领导者, 因此节点 2 直接进入追随者角色

消息广播
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
消息广播过程类似于二阶段提交过程:

    1. 领导者向每个追随者发送事务 (包含有分布式集群内的全局有序值 ZXID)
    2. 追随者执行事务
    3. 追随者向领导者反馈事务执行结果 (事务执行成功: Proposal ACK; 事务执行失败: 直接脱离分布式集群)
    4. 领导者接收到半数以上追随者发来的 ACK 消息, 则向每个追随者发送事务提交请求
    5. 追随者提交事务

    ┌────────────────────┐                                                                  ┌────────────────────┐
    │                    │  ╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌( 1. Ping            )╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌>  │                    │
    │                    │  <╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌( 2. Ping ACK        )╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌  │                    │
    │       Leader       │  ╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌( 3. Proposal        )╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌>  │      Follower      │
    │                    │  <╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌( 4. Proposal ACK    )╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌  │                    │
    │                    │  ╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌( 5. Proposal Commit )╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌╌>  │                    │
    └────────────────────┘                                                                  └────────────────────┘

阅读上述内容时, 还请注意:

    •  领导者不用等待每个追随者都反馈事务执行结果, 仅需过半追随者反馈事务执行的 ACK 消息, 领导者即可决断分布式集群进入事务的下一个阶段
    •  追随者要么反馈事务执行成功, 要么直接抛弃领导者, 脱离分布式集群

崩溃恢复
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~
崩溃恢复针对一种特殊情境设计: 领导者向每个追随者发送事务之后即刻宕机, 导致追随者存在未能提交的事务
崩溃恢复的实现过程如下:

    1. 软件集群触发领导选举, 选择事务编号最大的节点当选领导者, 存在 COUNT(MAX(ZXID)) > 1 时, 则进一步投票节点编号最大的节点为领导者
    2. 领导者采集其余追随者的 EPOCH 值, 并使用 MAX(EPOCH) + 1 的计算结果标记自己的领导任期
    3. 领导者向其余追随者广播事务数据, 追随者追加领导者有而自身没有的事务, 丢弃领导者没有而自身有的事务
    4. 软件集群再次进入消息广播工作模式



